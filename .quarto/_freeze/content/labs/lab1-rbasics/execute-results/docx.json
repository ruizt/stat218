{
  "hash": "3ac42d085da0bd3939d762a1f16e2300",
  "result": {
    "markdown": "---\ntitle: \"Lab 1: R Basics\"\nauthor: \"STAT218\"\nauthor-title: \"Course activity\"\nexecute: \n  eval: false\nformat: \n  html:\n    toc: true\n  docx:\n    toc: false\nprefer-html: true\nembed-resources: true\n---\n\n\n\nThis lab is intended to introduce you to the nuts and bolts of R: arithmetic operations, data types, vectors, and other data structures. While you won't be expected to do much data manipulation or manual calculation for this class, it will be helpful for you to have some understanding of this material going forward, as most R objects are arranged as data structures comprising one or more data types.\n\nThis lab covers a lot of ground; consider it a reference you can return to later as needed.\n\n### Arithmetic operations\n\nWhile R does a lot more than function as a calculator, it can be used to perform basic arithmetic. All of the usual operations --- addition, subtraction, multiplication, division, exponentiation --- can be performed as shown below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# addition\n2 + 1 \n\n# subtraction\n2 - 1\n\n# multiplication\n2*3\n\n# division\n2/3\n\n# exponentiation\n3^2\n\n# parentheses for order of operations: compare\n(2 + 1)/4\n2 + 1/4\n```\n:::\n\n\n\nBasic functions can also be evaluated. To name a few:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# square root\nsqrt(9)\n\n# exponential function e^x\nexp(1)\n\n# logarithm: compare, default base is e (i.e., natural log)\nlog(2, base = exp(1))\nlog(2)\n```\n:::\n\n\n\nThe result of each of these calculations is a *value*. Values are the most elementary objects in the R environment. Values can be assigned names using the assignment operator `<-`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# store a value\nx <- log(2)\n\n# print value in console\nx\n```\n:::\n\n\n\nNames can consist of any combination of letters, numbers, and the delimiters `_` and `.`; names cannot start with numbers (try it and see what happens).\n\nIf a name is used multiple times, the most recently assigned value will be stored. However, 'most recent' in this context means 'most recently executed': R will not pay attention to the order of lines in your script, but the order in which you run them. To see this, try redefining `x` to be a new value. if you then go back and run the previous line that displays the value, you'll notice you get the new value, not the old one, even though the line appears before the new assignment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# assign a new value the name 'x': this overwrites the first value\nx <- 4\n```\n:::\n\n\n\n::: callout-note\n## Your turn\n\nWrite one line of code each to perform the following calculations:\n\n1.  Calculate the sum of the ages of each member of your group, in years.\n\n2.  How about in months? Multiply by 12.\n\n3.  Calculate the average number of siblings among the members of your group.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sum of ages of group members\n\n# convert to months: multiply by 12\n\n# average number of siblings among group members\n```\n:::\n\n\n:::\n\n### Data types\n\nValues may be of different types. The function `class(...)` will return the \"class\" of object it is given; for values, the object class is simply the data type.\n\nThere are four main data types in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# numeric\nclass(12)\n\n# character\nclass('text')\n\n# logical\nclass(TRUE)\n\n# integer\nclass(12L)\n```\n:::\n\n\n\nArithmetic only works with logical, integer, and numeric values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# valid operations\n12*12\n12L*12\n12L*12L\n12*TRUE\n12*FALSE\n12L*TRUE\n12L*FALSE\n```\n:::\n\n\n\nIt will not work with character values. Notice the text of the error message:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# invalid operation\n'12'*'12'\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in \"12\" * \"12\": non-numeric argument to binary operator\n```\n:::\n:::\n\n\n\nThis is a very common error message â€” when you see it, you'll know that most likely, somewhere R attempted to perform arithmetic with character values, so it's probably a data type issue.\n\n::: callout-note\n## Your turn\n\n1.  Calculate the product of TRUE and FALSE. Which data type results from this operation?\n\n2.  What do you think will happen if you *add* a logical and numeric value? Discuss first, then verify.\n\n3.  What kind of value does each of the above operations return? Discuss first, then verify.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# product of true and false\n\n# add a logical and numeric value\n\n# check data type of the above\n```\n:::\n\n\n:::\n\n### Vectors\n\nIn practice, data usually consists of multiple values, not just one; in R, the most basic type of collection of values is called a *vector*. Technically, a vector is a \"concatenation\" of values of the same data type. Vectors can be formed using the concatenation function `c(...)`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# concatenate values with c(...) to form a vector\nc(1, 2, 3)\n\n# store it\nx <- c(1, 2, 3)\n\n# data type\nclass(x)\n```\n:::\n\n\n\nIf values of different types are concatenated, they are coerced to the same data type; vectors cannot contain values of mixed type. The lines below demonstrate this behavior:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# integer and logical -> integer\nclass(c(2L, TRUE))\n\n# integer and numeric -> numeric\nclass(c(2L, 12))\n\n# numeric and logical -> numeric\nclass(c(12, TRUE))\n\n# character and anything -> character\nclass(c('text', TRUE))\nclass(c('text', 2L))\nclass(c('text', 12))\n```\n:::\n\n\n\n#### Vectorization\n\nArithmetic between vectors is carried out elementwise; arithmetic operations between vectors and values are 'vectorized', meaning operations are applied over each element. This makes certain calculations quite efficient. The following examples illustrate vectorized arithmetic operations in two verbose ways: first as an elementwise operation between two vectors; then as a concatenation of the results of each elementwise operation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# equivalent\n2*c(1, 2, 3) # vectorized\nc(2, 2, 2)*c(1, 2, 3) # verbose\nc(2*1, 2*2, 2*3) # verbose\n\n# equivalent\nc(1, 2, 3) + 1 # vectorized\nc(1, 2, 3) + c(1, 1, 1) # verbose\nc(1 + 1, 2 + 1, 3 + 1) # verbose\n\n# equivalent\nc(1, 2, 3)/3 # vectorized\nc(1, 2, 3)/c(3, 3, 3) # verbose\nc(1/3, 2/3, 3/3) # verbose\n\n# equivalent\nc(1, 2, 3)^2 # vectorized\nc(1, 2, 3)^c(2, 2, 2) # verbose\nc(1^2, 2^2, 3^2) # verbose\n```\n:::\n\n\n\nIf an operation is carried out between vectors of different lengths, a warning is printed indicating as much.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# can you figure out what calculation was performed?\nc(1, 2, 3)*c(4, 5)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(1, 2, 3) * c(4, 5): longer object length is not a multiple of\nshorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 12\n```\n:::\n:::\n\n\n\nMany functions, including those mentioned at the outset, are also vectorized (calculations are performed elementwise).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(c(1, 4, 9))\nlog(c(1, 10, 100), base = 10)\nexp(c(0, 1, 2))\n```\n:::\n\n\n\n#### Indexing\n\nElements of vectors are *indexed* by consecutive integers; elements can be retrieved by specifying the indices in square brackets after the object name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define a vector\nx <- c(10, 20, 30, 40)\n\n# second element\nx[2]\n\n# first and third elements\nx[c(1, 3)]\n\n# second through fourth elements\nx[2:4]\n```\n:::\n\n\n\n#### Missing values\n\nMany datasets have missing values that occur for various reasons: equipment failure, participant dropout, survey nonresponse, and so on. These can be represented in R as well. This is useful as a means of retaining the information that there is an observation that was somehow lost. Missing values are displayed as the special character `NA` in R.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector with a missing third element\nc(1, 2, NA, 4)\n\n# note: still numeric\nclass(c(1, 2, NA, 4))\n```\n:::\n\n\n\n::: callout-note\n## Your turn\n\n1.  Create a vector with the ages of each person in your group (in years). Call it `ages`.\n\n2.  Convert to months using vectorized arithmetic.\n\n3.  Now pretend one of you is absent; repeat (1) but replace their age by a missing value. call the vector `ages_incomplete`.\n\n4.  Convert to months again using the same operation as in (2); how is the missing value handled?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector of ages in years\n\n# convert to months with vectorized arithmetic\n\n# pretend one person is absent: input a missing value\n\n# repeat conversion to months: how is the NA handled?\n```\n:::\n\n\n:::\n\n#### Matrices, arrays, lists, and data frames\n\nMatrices can be constructed from vectors by specifying row and column dimensions, and how to arrange the values -- by row or by column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4)\nmatrix(data = x, nrow = 2, ncol = 2, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n:::\n:::\n\n\n\nWe won't really see arrays much, but since they are mentioned in the reading, here's an example of how to construct one, and how it is displayed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5, 6, 7, 8)\narray(data = x, dim = c(2, 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n:::\n:::\n\n\n\nA list is a highly general data structure; it's just an indexed amalgamation of objects of any type.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make a list\nlist('anchor', c(22, 5), log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"anchor\"\n\n[[2]]\n[1] 22  5\n\n[[3]]\nfunction (x, base = exp(1))  .Primitive(\"log\")\n```\n:::\n\n```{.r .cell-code}\n# the list elements can be named, which makes for easy retrieval\nmy_list <- list(words = 'anchor', numbers = c(22, 5), functions = log)\nmy_list$words\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"anchor\"\n```\n:::\n\n```{.r .cell-code}\n# even so, indexing can still be used\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"anchor\"\n```\n:::\n:::\n\n\n\nData frames are like lists, except each element is a vector of the same length; they appear much like matrices, but behave differently in important ways.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make a data frame\ndata.frame(col1 = c(1, 2, 3, 4), \n           col2 = c(T, F, T, T), \n           col3 = c('red', 'blue', 'green', 'yellow'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  col1  col2   col3\n1    1  TRUE    red\n2    2 FALSE   blue\n3    3  TRUE  green\n4    4  TRUE yellow\n```\n:::\n\n```{.r .cell-code}\n# unlike matrices, however, columns can be retrieved by name\nmy_df <- data.frame(number = c(1, 2, 3, 4), \n                    truth = c(T, F, T, T), \n                    color = c('red', 'blue', 'green', 'yellow'))\n\n# the result is a vector containing the values of that column\nmy_df$color\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"red\"    \"blue\"   \"green\"  \"yellow\"\n```\n:::\n:::\n\n\n\nData frames are the fundamental data structure on which a large portion of R software is built. When data files are read into R, as you saw very briefly earlier, they are read in by default as data frames. Many R functions used in performing data analyses require data to be supplied as a data frame.\n\n::: callout-note\n## Your turn\n\nCreate a data frame in which each row corresponds to one member of your group and columns are the variables age, number of siblings, and favorite singer.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data frame with columns age, no. of siblings, and favorite singer; each row corresponds to one group member\n```\n:::\n\n\n:::\n",
    "supporting": [
      "lab1-rbasics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}